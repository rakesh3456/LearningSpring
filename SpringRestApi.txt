

Spring core framework
Spring boot
Rest api development using Spring

......................................................

Software setup:

1.JDK 11 | JDK 17 - Open JDK or Oracle JDK

2.IDE - Intellij Idea -Community Edition.
.....................................................................................
			   Spring Framework && Spring Boot
.....................................................................................

What is Spring Framework?

  Spring is Java Framework to build enterprise distributed application.

Types of application?
=>Desktop application
=>Network based application
   Apps runs in the remote machine and accessed that apps via network.
 =>Client Server Arch
	Application has three major layer(tier)
    ->Data Layer -Where we store data
    ->Biz layer - Where we process data
    ->Presentation Layer - Where we present  data

 ->Mainframe based arch
 ->Layered Client server arch without mainframeworks
    ->Single/One tier client server - >Both storage and biz processing kept in single 				      machine,where as ui layer is kept separately.

   ->Two/tier client server
        Database/Storage layer is separated, biz processing layer is kept in one 	machine, and ui also kept in the same machine.

   ->Three tier client server 
	Data layer , Biz processing layer, Ui layer is kept in different machines

   ->N-tier client server 
      Data Layer
      Biz processing layer
	->MOM Layer - Message oriented middlware -
        ->Rpc layer - Remote Procedure call-app to app interaction.
        ->Integration layer - ESB (Enterprise Server Bus)
    Each layer can be kept in different and different machines , each layer can communicate over network using its own networking protocals

What is Distributed Application?
    Distributed application is other wise called "N-tier client server arch"
 Software components runs in different and different machines and talks over networking using "its own protocal"..

How to build distributed apps?
   You can build distributed applications in any technology like "java",".netnet",php,python,node.js,.....

Distributed application types:
..............................
Now a days distributed apps are built using various patterns.

1.Monolithic Architecture pattern
    Legacy way of building "distributed apps"
2.Microservice Architecture pattern
    Modern way of building "distributed apps"


		 Since Spring is Distribtued java App framework
		  We can build "Mononlolithic" and also we can 
		    build "Microservices" based apps.


As a java developer, I need to know what are the concepts available to start 
building Monololithic apps in Spring.

1.Spring core Framework & Boot
2.Spring Data 
3.Api Development using webservices - Rest / Soap
4.Integration /MOM using Rabbitmq or Kafka....

As a java developer, I need to know what are the concepts available to start 
building Microservices apps in Spring.


1.Spring core Framework & Boot
2.Spring Data 
3.Api Development using webservices - Rest / Soap
4.Integration /MOM using Rabbitmq or Kafka....
5."Spring Cloud"- framework which provides all infrastructure
  to build Microservices based distributed apps.
....................................................................................
			 History Of Spring Framework
....................................................................................

Early 2000,Java become very popular for building distributed Applications.

Java Technology Types:

1.JSE 
   -Core java programming language
2.JEE
  -Building distributed apps 
3.JME
  -Device apps like mobile

JCP - Java Community Process
 Who standarize the entire Java Technology.

Java works based on Specification,
   Rules and regualations how things are working.

JSE - How java programming language works
JVM - How Java vm can be implementated.
....................................................................................
                             JEE -Enterprise Specification
.....................................................................................

JEE Platform spec : containers /app containers/tools

1.WebTechnology spec
 Java servlet
 JSP
 JSF
 Websocket
 JSTL
 EL
Enterprise Application spec
EJB
JPA -ORM
JMS
JTA
DI
Context and DI
Concurrency Util

Web Services

SOAP based  -JAX-WS
REST Based  -JAX-RS

Management and Security technologies
........................................
Java EE Security spec
Java Auth
Java authorzation
JAVA EE additional spec
JMX -Jmeter
....................................................................................
				  
 		Complixty of JEE Spec and implementation
.....................................................................................

JEE enterprise application:
............................

Client Layer         Web Layer      Biz layer      Data Layer/Persistency

Browser             Servlet/JSP      EJB               Entity Beans

EJB :Enterprise Java Bean
  Java Object can support distributed biz operations
eg: incase of shopping cart
  I have a bean(java object) which has three apis addToCart,Checkout,Payment)

Api classifications:
1.Session Bean  - to represent biz logic---jdbc--dml
2.Enitity bean  -ORM - Object to Table mapping-First orm solution---Hibernate
3.Message Driven Bean - Message driven systems-RabbitMQ,Kaffka,JMS

Rod johnson  was working in enterprise banking application with jee, he faced lot of 
complexity in designing ejb driven systems, so he decided to move out ejb from JEE application, he wrote book called expert  J2EE ONE ON ONE design and development.


He proposed a model  that model later on came as The project in "Spring Season" - Spring Framework.

Client Layer         Web Layer      Biz layer                Data Layer/Persistency

Browser             Spring MVC     Spring Services              Spring-orm - Spring-data

Spring development objective is "POJO". (Plain Old Java Object)

When you build enterprise java apps, no plumbing(bolier plate code),Spring framework takes care that plumbing.


Java is Object Oriented Programming language.

Apps built on java collection of objects.

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency

1.Object Management :Hierarchy

Object Relationship

-HAS-A -  Composition
-IS-A - Inheritance.

Enterprise application challanges:

1.Object Management

IOC : Inversion of Control
 Inversion -Do opposit
 of Control -Management

In enterprise application object creation and linking objects are so complex that should be removed from the developer.

Someone should take care object creation and linking= 
  =>This process is called as IOC.
The IOC suggest the automation program,that program called as IOC Container.


class Order {
   Product product
}

class Customer{
   Order order
}

class Product {
  Item item
}
class Item {

}

Customer information
 ->Order
     -Product
        -Item

You have to create Object Object for every class
You have to pass object reference to every Object - HAS-A

 new Customer(new Order(new Item()))
	IOC

 Invert- Do opposit 
 ofControl -Management

 Do opposit Management 

Management - creating object and mainitain its relationship references
		-developer via code

Do Opposit - Dont create create object , dont management object life cycle
   IOC
Some body has to create objects and manage its relationship - "Automated Program"
   -IOC Container

ioc container implementation:
 -Spring framework provides at core ioc container - Spring Context
.....................................................................................
			Spring Application
.....................................................................................
   The application is written in java technology, executed on Spring Container which is runtime for spring applications.spring container runs on jvm


			  Spring Application
				 |
			   Spring Container
				 |
				JVM


what is framework?
   One Stop Solution
 Collection of tools and technologies provided in one place to build end to end applications mostly.
  
What spring framework offers?

 Spring offers collection of many projects.

1.Core:

IoC container,
Events, 
Resources, 
i18n,
Validation,
Data Binding,
Type Conversion, 
SpEL,
AOP.

2.Spring MVC
3.Spring cloud
etc....
https://spring.io/projects/
.....................................................................................
				Spring Core principle
.....................................................................................

Make Java enterprise distribute application easy way.

=>IOC and Dependency Injection
     -How to create objects and how to link objects.

Spring Provides

1.Application code
   classes which expose biz logic and apis

2.Infrastructure code
  creating objects
  initalization dependencies

Spring takes care of infra code, where develper takes care of app code.

Object Creation In spring:
.........................
 In Spring Object creation and linking objects must be separated from the developer
 -IOC and DI

Core Project
1.XML driven
2.Java Config Driven
3.Boot Driven

Spring Modules
...............
2.Web
Web Servlet	
 Spring MVC, WebSocket, SockJS, STOMP messaging.

Web Reactive	
  Spring WebFlux, WebClient, WebSocket.


3.Data Access
  SQL, NOSQL
SQL:
Transactions, DAO support, JDBC, ORM, Marshalling XML.
NOSQL
Mongodb....


Integration	
  Remoting, JMS, JCA, JMX, Email, Tasks, Scheduling, Cache.

Languages	
     Kotlin, Groovy, Dynamic languages.

Microservices

Reactive

Cloud 

Event Driven

Serverless
.....................................................................................
				   Tools For Spring Application Development
....................................................................................
1.JDK  11
   HotSpot or OpenJDk
2.Build Tools
   Maven,Gradle
3.Docker

Spring Versions and features

2004 - Spring Framework 1.0 released
– Champions dependency injection
– Encourages POJOs
– Uses XML files to describe application
  configuration
– Becomes popular quickly as an EJB
  alternative

• Spring 2.0 (2006):
 – XML simplification, async JMS, JPA, AspectJ support

• Spring 2.5 (2007, last release 2.5.6)
  – Requires Java 1.4+ and supports JUnit 4
  – Annotation DI, @MVC controllers, XML namespaces

• Spring 3.x (3.2.17 released July 2013)

   – Environment & Profiles, @Cacheable, @EnableXXX …
   – Requires Java 1.5+ and JUnit 4.7+
   – REST support, JavaConfig, SpEL, more annotations

• Spring 4.x (released Dec 2016)
    – Support for Java 8, @Conditional, Web-sockets

• Spring 5.x (2017)
  MicroService driven Dev features
   – Reactive programming focus
   - Functional Programming
   - Cloud Functionality
   - Container support

• Spring 6.x (2023)
   -Java 11 and 17 LTS support
   -Only improvments and bug fixing

Spring Boot:
  Spring was available inside Spring Framework 5.x 
  later it became independant project
  Now days only Spring boot is defacto standard for configuring spring applications
  
  Spring boot 3.1 is new Spring Boot Release
....................................................................................
				Spring Core Concepts
....................................................................................

Spring Core Concepts:

1.Spring Bean

What is Bean?
   
  Bean is terminallogy coined by SUN Micro System to name java object.

Object vs Bean?

 -Same but Bean has some special characteristics  which was proposed by SUN micro system via 
"Java Bean Spec"

It is java class, based Java Bean standards
 	-class should be public
 	-properties should be private
 	-set and get methods - Accessors and mutators
	-constructors

Why Bean Spec?
  - in order to standarize the java dev process- Coding Standards.

public class Customer {
  private  int id;
  private String name;
}
    "Spring  follows java bean spec in order to create object and links objects"

class CustomerService {

   private CustomerRespository rep;

   CustomerService(){

   }
   set /get

}
class CustomerRespository{


}

Spring Bean is Java Object follows Bean Specification and also managed by Spring Container.

.....................................................................................			  	 Spring Bean Creation(Object)
.....................................................................................


Who creates Spring Beans?

 -Spring Container

 Spring container is java object, which manages object(bean) life cycle like   create,use,destroy.

How spring beans are created?

-> you must have bean definitions outside application biz logic
-> sp container reads that bean definitions, initalizes the beans.

Architecture:

			POJO Classes(Bean)
				 |
    Spring-Application <====>SpringContainer
      config file		 |
		       Fullyconfigured System


Spring Bean Definitions(file) instructs Spring Container how to create objects(order of creations) and how to link (DI) objects

....................................................................................
			Spring Application Configuration Management
.....................................................................................

Spring Application can be configured in many ways

1.XML files  -  Old and Legacy.

2.Java Config + Annotations

2.1 Java Config -Manual - Write Configuration and logic

 Here Dev need to write Configuration and biz logic , which makes app dev slower.

Just Focus logic, automate configuration itself - AutoConfig

3.AutoConfig:
    Framework must take care of configuration based on various conditions like
 i want web and jpa , messaging.
                        "Birth of Spring Boot"

....................................................................................
				Spring Project Setup 
	    

What are the required components to setup Spring Project.

1.IDE,mvn,java

2.Project layout


Spring Project requires

Infra Structure:
 1.Project libraries

 2.Project Configurations

Application Structure

1.Application code
2.assets - imgs,docs
3.App Configuration

mvn or gradel

.............................................................................................
				    Spring Project Creations
............................................................................................

Whether you build app using Boot or Old Spring Framework Two things you have to take care

1.Project Dependency -  Libraries- core,web,data,cloud,logger....
  You have to manage
  Spring have to manage - Boot via starters

2.Application Configuration
   -Bean defintions -  xml
   

Spring Project Using Spring Framework method:

Steps:

1.create Plain Maven Project

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>myspringframework</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-core -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>6.0.10</version>
        </dependency>
    </dependencies>
</project>


2.place beans.xml in the class path - resources/beans.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->

</beans>

3.Configure the Bean in beans.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
        <bean id="hello" class="com.ibm.spring.app.HelloWorld" />
</beans>

4.Load Bean Definitions and Access the Bean
package com.ibm.spring.app;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BeanCreationWithSpring {
    public static void main(String[] args) {
      //Load Spring Container:XMLContainer,JavaConfigContainer,BootContainer
        ApplicationContext context =new ClassPathXmlApplicationContext("beans.xml");
        HelloWorld helloWorld = context.getBean(HelloWorld.class);
        System.out.println(helloWorld.sayHello());
    }
}
.............................................................................................
				 Dependency Injection
............................................................................................

What is dependency Injection?

  Linking objects
  Setting Object Property values

  Setting Object references with Object who refers it.

Dependency Injection on reference types and Primitives

eg:
  OrderService needs OrderRepository


Types of DI:

1.Setter
    Linking objects after objects created
2.Constructor
    Linking objects, During object creation.

When to use Setter vs Constructor?

Note: 
 Constructor properties are initlized during object creations
 Settter properties are initlized after object creations

Spring supports both.You can mix and match.

Constructors:
  ->Enforce mandatory dependencies

Setters:
 1.Allow optional dependenices
....................................................................................
			
Dependency Injection:
.....................
beans.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
        <bean id="hello" class="com.ibm.spring.app.HelloWorld" />

<!--    Setter injection-->
    <bean id="address" class="com.ibm.spring.app.di.Address">
        <property name="city" value="coimbatore"></property>
    </bean>
      <bean id="customer" class="com.ibm.spring.app.di.Customer">
            <property name="customerId" value="10"/>
            <property name="name" value="Subramanian"/>
            <property name="address" ref="address"/>
      </bean>

<!--    -->
    <bean id="newCustomer" class="com.ibm.spring.app.di.Customer">
        <property name="customerId" value="12"/>
        <property name="name" value="Ram"/>
        <constructor-arg ref="address"/>
    </bean>
</beans>

Beans.

package com.ibm.spring.app.di;

public class Customer {
    private int customerId;
    private String name;
    //Depedency
    private  Address address;

    public Customer() {
    }

    public Customer(Address address) {
        this.address = address;
    }

    public Customer(int customerId, String name, Address address) {
        this.customerId = customerId;
        this.name = name;
        this.address = address;
    }

    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Customer{" +
                "customerId=" + customerId +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }
}

Address.java
package com.ibm.spring.app.di;

public class Address {
    private String city;

    public Address() {
    }

    public Address(String city) {
        this.city = city;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                '}';
    }
}

Main:
package com.ibm.spring.app.di;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class CustomerMainDI {
    public static void main(String[] args) {
        ApplicationContext context =new ClassPathXmlApplicationContext("beans.xml");
        //setter injection
        Customer customer = context.getBean("customer",Customer.class);
        System.out.println(customer);
        customer.setCustomerId(234);
        customer.setName("Ram");
        customer.getAddress().setCity("Chennai");
        System.out.println(customer);

        //constructor injection
        Customer customer1 = context.getBean("newCustomer",Customer.class);
        System.out.println(customer);

    }
}

.....................................................................................
				Dependency Injection values

1.You can inject primitives values- int,float,string,char,boolean
2.You can inject objects -Customer ,Address
3.You can inject list - Collections,Map,List,Set
............................................................................................
			 Program to Super Type - Interface Driven DI
............................................................................................


beans.xml
    <bean id="inmemory" class="com.valtech.spring.beans.di.interfaces.CustomerInMemoryRepositoryImpl"></bean>
    <bean id="jpaimpl" class="com.valtech.spring.beans.di.interfaces.CustomerJPARepositoryImpl"></bean>
    <bean id="customerservice" class="com.valtech.spring.beans.di.interfaces.CustomerService">
        <constructor-arg ref="inmemory"/>
    </bean>


package com.valtech.spring.beans.di.interfaces;

public interface CustomerRepository {
    String findAll();
}
package com.valtech.spring.beans.di.interfaces;

public class CustomerInMemoryRepositoryImpl implements  CustomerRepository{
    @Override
    public String findAll() {
        return "CustomerInMemoryRepositoryImpl";
    }
}
package com.valtech.spring.beans.di.interfaces;

public class CustomerJPARepositoryImpl implements CustomerRepository {
    @Override
    public String findAll() {
        return "CustomerJPARepositoryImpl";
    }
}
package com.valtech.spring.beans.di.interfaces;

public class CustomerService {
    //di with interface
    private CustomerRepository repository;

    public CustomerService(CustomerRepository repository) {
        this.repository = repository;
    }

    public CustomerService() {
    }

    public CustomerRepository getRepository() {
        return repository;
    }

    public void setRepository(CustomerRepository repository) {
        this.repository = repository;
    }

    public String findAll() {
        return repository.findAll();
    }
}

package com.valtech.spring.beans.di.interfaces;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class CustomerInterfaceApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        CustomerService customerService = context.getBean("customerservice", CustomerService.class);
        System.out.println(customerService.findAll());
    }
}
.............................................................................................
DI Values:
 You can inject primtives / scaller such as int,sting,char,boolean
 You can inject Objects(reference types) - Customer,Order,Address,Repository
 You can inject Collection types - such as List,Map,Set...

Proerty can have child elements:List
<property name="shippingAddress">
	<list>
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
		<ref bean="address" />
	</list>
</property>
or via constructor
	<constructor-arg name="orders">
			<list>
				<ref bean="orderA" />
				<ref bean="orderB" />
				<ref bean="orderC" />
			</list>
		</constructor-arg>

<list> -ArrayList
............................................................................................
How to add List as dependency?

beans.xml
 <bean id="customer" class="com.valtech.spring.beans.di.Customer">
        <property name="customerId" value="1"/>
        <property name="name" value="Subramanian"/>
        <!--Setter Injection-->
        <property name="address" ref="address"/>

        <constructor-arg>
              <list>
                  <ref bean="orderA" />
                  <ref bean="orderB" />
                  <ref bean="orderC" />
              </list>
        </constructor-arg>
    </bean>

package com.valtech.spring.beans.di;

import java.util.List;


package com.valtech.spring.beans.di;

public class Order {
    private int orderId;
    private float orderValue;

    public Order() {
    }

    public Order(int orderId, float orderValue) {
        super();
        this.orderId = orderId;
        this.orderValue = orderValue;
    }


    public int getOrderId() {
        return orderId;
    }

    public void setOrderId(int orderId) {
        this.orderId = orderId;
    }

    public float getOrderValue() {
        return orderValue;
    }

    public void setOrderValue(float orderValue) {
        this.orderValue = orderValue;
    }

    @Override
    public String toString() {
        return "Order{" +
                "orderId=" + orderId +
                ", orderValue=" + orderValue +
                '}';
    }
}


public class Customer {
    private int customerId;
    private String name;
    private Address address;
    private List<Order> orders;


    public Customer(List<Order> orders) {
        this.orders = orders;
    }

    public List<Order> getOrders() {
        return orders;
    }

    public void setOrders(List<Order> orders) {
        this.orders = orders;
    }

    public Customer() {
    }

    public Customer(int customerId, String name) {
        this.customerId = customerId;
        this.name = name;
    }

    public Customer(Address address) {
        this.address = address;
    }

    public Customer(int customerId, String name, Address address) {
        this.customerId = customerId;
        this.name = name;
        this.address = address;
    }

    @Override
    public String toString() {
        return "Customer{" +
                "customerId=" + customerId +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    public int getCustomerId() {
        return customerId;
    }

    public void setCustomerId(int customerId) {
        this.customerId = customerId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
package com.valtech.spring.beans.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class CustomerDIApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        System.out.println(customer.getOrders());


    }

}
.....................................................................................
Bean Definitions:
1.How to create bean 
   class,factory-method

2.How to name beans?
   id,name,alias

3.scope of the beans? : visibility of the bean
   singleton,prototype,
   request,session,application,websocket

4.Dependence Injections
   constructor
   setter
   autowire

5.Lazy initialization mode
 controlling bean creations
  eagar-default
  lazy-ondemand
  lazy-init="true"

5.How to simplify bean injections? 
   Autowiring mode 
 no,byName,byType,constructor  
.....................................................................................
.............................................................................................
					Bean Creation
............................................................................................

1.Via class  
   Spring creates using new Operator
  new Order()

2.Via Factory Pattern

-if constructor marked private
   via factory factory api


beans.xml
        <bean id="authService" class="com.ibm.spring.app.di.factory.AuthService"  factory-method="getInstance"/>

AuthService.java
package com.ibm.spring.app.di.factory;

public class AuthService {
    private String userName = "admin";
    private String password = "admin";

    private AuthService() {
    }
    // Factory Api
    public static AuthService getInstance() {
        return new AuthService();
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
Main
package com.ibm.spring.app.di.factory;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class FactoryMain {
    public static void main(String[] args) {
        ApplicationContext context =new ClassPathXmlApplicationContext("beans.xml");
        AuthService authService = context.getBean(AuthService.class);
        System.out.println(authService.getUserName());
    }
}
...........................................................................
			Bean Scopes
.....................................................................................
Generally, you can create multiple instance from bean definition.
  some times if you want to control that bean creation
you can use bean creation scope.

Spring supports 6 scopes:

1.singleton
 (Default) Scopes a single bean definition to a single object instance for each Spring IoC container.
 if you call getBean no of time, spring returns the only one instance at any point of time.
This is default scope.

<bean id="clientService" class=" com.ibm.spring.app.di.beanscope.ClientService"/>

package com.ibm.spring.app.di.beanscope;

public class ClientService {
    public void findAll() {
        System.out.println("Client Service-findAll");
    }
}
package com.ibm.spring.app.di.beanscope;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SingleTon {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");

        ClientService clientService = null;
        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());
        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());
        clientService = factory.getBean("clientService", ClientService.class);
        System.out.println(clientService.hashCode());
    }
}
.
2.prototype:
a new bean instance is created every time a request for that specific bean is made 
that is, the bean is injected into another bean or you request it through a getBean() method call on the container.


beans.xml
 <bean id="clientService" class="com.valtech.spring.beans.scopes.ClientService" scope="prototype" >
 </bean>

package com.ibm.spring.app.di.beanscope;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class PrototypeMain {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");

        ClientService clientService = null;
        clientService = factory.getBean("clientProtoService", ClientService.class);
        System.out.println(clientService.hashCode());
        clientService = factory.getBean("clientProtoService", ClientService.class);
        System.out.println(clientService.hashCode());
        clientService = factory.getBean("clientProtoService", ClientService.class);
        System.out.println(clientService.hashCode());
    }
}
Web Scope:
3.request 
 <bean id="flight" class="com.ae.trip.entity.Fight" scope="request"/>
	HttpServletRequest req;
	req.setAttribute("flight",flight)
	
	->Servlet--->Servlet---Servlet---NServlet---jsp
	->Servlet----jsp---Servlet--->Servlet--Jps....
4.session
	Single User multiple request,storing data about single User
	HttpSession session;
	session.setAttribute("flight",flight)
      <bean id="flight" class="com.ae.trip.entity.Fight" scope="session"/>
	User---ShoppingCart
	User---CheckoutScreen
	User---PaymentScren
5.application
	Global Data, eg Offers for all users in the web site
	ServletContext ctx;
	ctx.setAttribute("flight",flight)
	<bean id="offer" class="com.ae.trip.entity.Offer" scope="application"/>
6.websocket

 ->The request, session, application, and websocket scopes are available only if you use a web-aware Spring ApplicationContext implementation (such as XmlWebApplicationContext)
			.....................................................................................
				DI automations
.....................................................................................
autowire:

Dependency Injections:
 ->property - setter injections
 ->constructor-arg ref ->constructor injections

 
->autowire 
Which is not new injection type, but it simplifies property and constructor injections

     no ->Explicit via property or constructor-arg
     byName - Implicit via property
     byType - Implicit via type + property
     constructor - Implicit via constructor
Dependency Injections:
 ->property - setter injections
 ->constructor-arg ref ->constructor injections
 
Lab:

Customer
    |
    Account
    Address ---->via autowire


eg:
  <bean id="customerAuto" class="com.ibm.spring.app.di.Customer" autowire="byType">
        <property name="customerId" value="10"/>
        <property name="name" value="Subramanian"/>
<!--        <property name="address" ref="address"/>-->
    </bean>
   <bean id="address" class="com.ibm.spring.app.di.Address">
        <property name="city" value="coimbatore"></property>
    </bean>

package com.ibm.spring.app.di;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AutoWireDi {
    public static void main(String[] args) {
        ApplicationContext context =new ClassPathXmlApplicationContext("beans.xml");
        Customer customer = context.getBean("customerAuto",Customer.class);
        System.out.println(customer);


    }
}
Bean life cycles:
.................
init
destroy

Points:
1.if you want to initalize the resources,
 Resources:
   Resource is nothing but ,something outside jvm
    ex: FileSystem,Databases,Network sockets,Graphics context....
  Resources must be mananaged properly , if not , it will give you
 memory leaks.

In general , resources are initialized inside Class constructors
eg:Establishing database,socket connections, create file points,open file

According to spring best practices, dont do it inside constructor
 Why
   WHich hindrences the bean intialization, which will drop app startup performance.

then where can i initlaize
 spring provides life cycle hooks

   ->init-method="initmethod"
   ->destroy-method="destroymethod" - Resouce clean up

    <bean id="customerLifeCycle" class="com.ibm.spring.app.beanlifecycle.CustomerService" init-method="init" destroy-method="destroy" />


package com.ibm.spring.app.beanlifecycle;

public class CustomerService {

    public void init(){
        System.out.println("Init");
    }
    public  void destroy(){
        System.out.println("Destroy");
    }
}

package com.ibm.spring.app.beanlifecycle;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class LifeCycleMain {
    public static void main(String[] args) {
        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");
        factory.getBean(CustomerService.class);

    }
}


package com.ibm.spring.app.beanlifecycle;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class LifeCycleMain {
    public static void main(String[] args) {
//        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");
        ConfigurableApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");

        factory.getBean(CustomerService.class);
        factory.registerShutdownHook();

    }
}

How to call destroy hook method on bean?

BeanFactory
 |
org.springframework.context.ApplicationContext
 |
->org.springframework.context.ConfigurableApplicationContext
   |
  registerShutdownHook();------->destroy method


    <bean id="customerLifeCycle" class="com.ibm.spring.app.beanlifecycle.CustomerService" init-method="init" destroy-method="destroy" />

package com.ibm.spring.app.beanlifecycle;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class LifeCycleMain {
    public static void main(String[] args) {
//        ApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");
        ConfigurableApplicationContext factory = new ClassPathXmlApplicationContext("beans.xml");

        factory.getBean(CustomerService.class);
        factory.registerShutdownHook();

    }
}
.....................................................................................
			 Container Extensions Points
.....................................................................................

Typically, an application developer does not need to subclass  ApplicationContext implementation classes.

 Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. 

Typically, an application developer does not need to subclass  ApplicationContext implementation classes.

 Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. 

Spring core System:

		  Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|
		| Spring IOC Container  |
		------------------------
			|
		       JVM

 How to add extensions(plugins) on to the Existing Spring Container?


 		 Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|--->Extensions
					|    1.BeanPostProcessor 
		|			|     etc...
		|			|
		| 			|
		| Spring IOC Container  |
		|			|
		|			|	
		|			|
		|		        |
		------------------------
			|
		       JVM

Features
1.How to instrument beans
2.How to instrument containers


BeanPostProcessor: Extensions
..................
  BeanPostProcessor are classes that tells Spring what should be done after beans are created.

    <bean class="com.ibm.spring.app.extensions.BeanPostProcessorExtension"/>

package com.ibm.spring.app.extensions;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class BeanPostProcessorExtension implements BeanPostProcessor {

    //This method will be called after bean creation
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization : " + bean + " " + beanName);
        return bean;
    }

    //this method will be called before before bean creation.
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization : " + bean + " " + beanName);
        return bean;
    }
}

2.BeanFactoryPostProcessor : Container Extension, where we instrument container itself.

<bean class="com.ibm.spring.app.extensions.FactoryBeanPostProcessorExtension"/>
package com.ibm.spring.app.extensions;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;

public class FactoryBeanPostProcessorExtension implements BeanFactoryPostProcessor {

    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

        System.out.println("Container Extensions : " + beanFactory);

    }

}
.....................................................................................

	  More Container Features(extensions)

             Spring Application
			|	
 	    Configuration Management System
		 (tools-XML,Annotations)
		-------------------------
		|			|--->Extensions
					|    1.BeanPostProcessor 
		|			|    2.Features2
		|			|    3.Feature3
		| 			|    4.FeatureN
		| Spring IOC Container  |
		|			|
		|			|	
		|			|
		|		        |
		------------------------
			|
		       JVM


	Spring provides lot of built in Extensions


PropertyPlaceholderConfigurer :
   It is used to externalize the bean property values
eg:

Bean defintion file
<bean id="customer" class="com.ae.spring.entity.Customer"
  <property name="customerId" value="100">
</bean>

With PropertyPlaceHolder = ${propertykey} => propValue
eg: 
<bean id="customer" class="com.ae.spring.entity.Customer"
  <property name="customerId" value="${customer.id}">
</bean>

PropertyPlaceholderConfigurer 

classpath:customer-info.properties
customer.id=1
customer.name=Ram

eg:
Steps:
1.property file
src/main/java/customer-info.properties
customer.id=1
customer.name=Ram
2.Activate Extension to read Property file
  ->
<beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="locations" value="classpath:customer-info.properties" />
</bean>

3.Read Property value:
		ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
		Customer customer = context.getBean("customer", Customer.class);
		System.out.println(customer.getId() + " " + customer.getName());
....................................................................................
	  How to introduce Annotations -Annotation Driven configuration
.....................................................................................
Annotations:
 Meta Information about class,methods,fields.

Why Annotation?
 Annotations help to inject "boiler plate code" -The code which is not neccessary for the dev but necessary for compiler,build tools,document generation tools,runtime.

Spring Introduced Annoations to simplify the lot of code generations.

Types of Spring Annotations

1.Spring Properity annotations
2.JSR 250 Annotations 


How to introduce Annotations inside Spring?
 
 Via ContainerExtension Mechanism


Common Annotations:
1.RequiredAnnotationBeanPostProcessor - @Required
2.AutowiredAnnotationBeanPostProcessor  -@Autowrited
3.CommonAnnotationBeanPostProcessor  -@Common
4.PersistenceAnnotationBeanPostProcessor -@Entity
etc....

Steps to integrate Annotations:

1.Activate The Annoation via ContainerExtension Point Beans

beans.xml

 <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/>
 -@Required

 -@Autowried
<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>


What if any one of the AnnotationBeanPostProcessor has its own dependency, we need to inject
That as well, other wise it will throw error.

what if i want to use more annotations, i need to add more AnnotationBeanPostProcessor beans in bean.xml
  This is very complex

Note: modern spring has implicitly added annoation post bean processors , so you dont need to add "Core Annotation BeanPostProcessor in beans.xml".

eg:
beans.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--  Required Annotation Bean Post Processor-->
    <bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/>
    <bean id="student" class="com.ibm.spring.app.annotations.Student">
         <property name="name" value="Subramanian"/>
          <property name="age" value="43"/>
     </bean>
</beans>
Student.java
package com.ibm.spring.app.annotations;

import org.springframework.beans.factory.annotation.Required;

public class Student {
    private  Integer age;
    private  String name;

    public Integer getAge() {
        return age;
    }

    @Required
    public void setAge(Integer age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
package com.ibm.spring.app.annotations;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class RequiredAnnotationMain {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beansannotation.xml");
        Student student = context.getBean(Student.class);
        System.out.println(student);

    }
}

How to test this program?
Just comment age property and run the code see the error.
    <bean id="student" class="com.ibm.spring.app.annotations.Student">
         <property name="name" value="Subramanian"/>
<!--          <property name="age" value="43"/>-->
     </bean>
Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'student' defined in class path resource [beansannotation.xml]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Property 'age' is required for bean 'student'
.....................................................................................
				Automation - Annoation Scanner
.....................................................................................

Spring added feature called automated scanner, which scans all annoations from the build path/class path, creates all the beans related to annotationBeanPostoer

How to tell spring container to scan annotations?

beansscanner.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
       <!--      Activate all AnnoationBean Post Processors-->
      <context:annotation-config/>

    <bean id="address" class="com.ibm.spring.app.annotations.Address">
             <property name="city" value="Coimbatore"/>
    </bean>
    <bean id="student" class="com.ibm.spring.app.annotations.Customer">
            <property name="id" value="1"/>
            <property name="name" value="Subramanian"/>
    </bean>
</beans>

package com.ibm.spring.app.annotations;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AutoWiredAnnotationMain {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("beansscanner.xml");
        Customer customer = context.getBean(Customer.class);
        System.out.println(customer);

    }
}

package com.ibm.spring.app.annotations;

import org.springframework.beans.factory.annotation.Autowired;

public class Customer {
    private  int id;
    private String name;

    @Override
    public String toString() {
        return "Customer{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    @Autowired
    private Address address;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
package com.ibm.spring.app.annotations;

public class Address {
    private String city;

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                '}';
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}
....................................................................................
				Bean Life Cycles and annoatations

in order to add life cycle annotations which is not part of spring core which is part of jsr 250. we need to add separate depedency.

in pom.xml
  <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
   </dependency>

eg:
package com.ibm.spring.app.annotations;

import org.springframework.beans.factory.annotation.Autowired;

import javax.annotation.PostConstruct;

public class Customer {
    private  int id;
    private String name;

    //life cycle methods
    @PostConstruct
    public void init(){
        System.out.println("Init");
    }

    @Override
    public String toString() {
        return "Customer{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    @Autowired
    private Address address;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
.....................................................................................
			How to reduce code slowly via annotations
.....................................................................................
Types of Annotations
.....................................................................................

1.JSR 250 annoations

@PostConstruct
@PreDestroy

2.Spring Annoations
@Required,@Autowired......etc...

You have beans.xml with annotation configuration, but still we have bean creation definitions how to remove those areas.

How to remove bean definitions from the beans.xml file

   <bean id="student" class="com.ibm.spring.app.annotations.Customer">
            <property name="id" value="1"/>
            <property name="name" value="Subramanian"/>
   </bean>

.........
					Types of Annotations
..............................................................................................

1.JSR 250 annoations

@PostConstruct
@PreDestroy


2.Spring Annoations

How to remove bean definitions from the beans.xml file

<bean id="customer" class="com.valtech.beans.Customer" />

Stereotype Annotations:

Stereotype: "Same type of things but it adds extra behaviour based on context"


@Component

What is Component?

The term coined by Microsoft in 1989.
In Object Oriented System Every thing is Object
The Term object is more general term.

Component is also Object(Bean) in spring context
  ->It is resulable
  ->follows all java bean standards

In java technology:
Bean
 In java Bean is called "java Object Only"

EJB
 It is also java object, which is distributed

Enitity
 It is also java object, which is persitable into fs,networks,rdbms



What is use of @Component?
 ->To eleminate bean definition from beans.xml file

<bean id="customerService"  class="com.ae.spring.service.impl.CustomerServiceImpl"/>


Spring provides  stereotype annotations:
 @Component is core type

Api doc:

 @Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Indexed
public @interface Component

@Component is class level annotation,declared on the top of class.

Indicates that an annotated class is a "component"
Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning.

Auto-detection and component scanning:

base package: com.ae.spring
			    com
			     |
			    ae
			     |
                           spring
		    -----------------------------
		   |                            |
                service                        repo
		   |                            |
		 impl                          impl
-------------------------------       -----------------------------
  |               |                   |                          |
CustomerService ProductService     CustomerRepoImpl          ProductRepoImpl
Impl            Impl

@Component      @Component         @Component                @Component
.............................................................................................
			Automation - Stereotype Annoation Scanner
   ..............................................................................................
   
How to scan SteroTypes?

 <context:component-scan base-package="com.valtech.spring.beans.automation"/>

This package and its subpackages , scan and creates beans and make it ready.

@Component is a generic stereotype for any Spring-managed component.

@Repository, @Service, and @Controller are specializations of @Component for more specific use cases.

by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects.

.............................................................................................
				DOMAIN Driven Design
.............................................................................................

 
@Service:

@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Service

Indicates that an annotated class is a "Service", originally defined by Domain-Driven Design (Evans, 2003) as "an operation offered as an interface that stands alone in the model, with no encapsulated state."


@Repository:
@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Repository

indicates that an annotated class is a "Repository", originally defined by Domain-Driven Design (Evans, 2003) as "a mechanism for encapsulating storage, retrieval, and search behavior which emulates a collection of objects".

...........................................................................................

@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 @Component
public @interface Controller
Indicates that an annotated class is a "Controller" (e.g. a web controller).
.....................................................................................

beansStreotype.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--      Activate all AnnoationBean Post Processors-->
    <context:annotation-config/>
<!--    Activate Stero type annoations : spring will pick up bean defintions-->
    <context:component-scan base-package="com.ibm.spring.app.annotations.sterotypes"/>
</beans>

Customer.java

package com.ibm.spring.app.annotations.sterotypes;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class Customer {
    private  int id;
    private String name;

    //life cycle methods
    @PostConstruct
    public void init(){
        System.out.println("Init");
    }

    @Override
    public String toString() {
        return "Customer{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address=" + address +
                '}';
    }

    @Autowired
    private Address address;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
package com.ibm.spring.app.annotations.sterotypes;

import org.springframework.stereotype.Component;

@Component
public class Address {
    private String city;

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                '}';
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

.....................................................................................

				 End of Xml Configuration
.............................................................................................

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!--scanner for common Annotation -->
    <context:annotation-config/>
    <!--    Scanner for StreoType Annotations-->
    <context:component-scan base-package="com.valtech.spring.beans.automation"/>
</beans>
....................................................................................
..............................................................................................
		What if i want to remove this beans.xml itself
			    Java Config
.............................................................................................

Thanks to XML ,Good bye to XML,Welcome to Java Config:
......................................................

What is Java Config?

JavaConfig <=======> beans.xml
  but it is pure java Program.

Why Java config?
  Java Config was introduced to remove XML,
The XML is outside spring.
Spring need to parse xml file and construct objects accordingly
Which is heavy weight.
Spring introduced new configuration system which is written in java itself.

package com.ibm.spring.app.javaconfig;

import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    public String findAll() {
        return "Customer Service";
    }
}

package com.ibm.spring.app.javaconfig;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //beans.xml
public class AppConfig {
    //method to create Object
    @Bean //<bean class="">
    public CustomerService getCustomerService(){
        return  new CustomerService();
    }
}
package com.ibm.spring.app.javaconfig;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class JavaConfigMain {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
        CustomerService customerService = ctx.getBean(CustomerService.class);
        System.out.println(customerService.findAll());
    }
}
.....................................................................................
			.....................................................................................................
				How to simplify or modularize the bean creations
....................................................................................................

Modulariazation:
...............

Can we have multiple bean definition files- modular definition files

1.XML is so complex to maintain when app grows.
   -In general we can have multiple configurations
  like
	projectname-dao.xml
	cleartrip.dao.xml 
        cleartrip.service.xml
        cleartrip.entitis.xml
	cleartrip.beans.xml
via Program:
ConfigurableApplicationContext context = ClassPathXmlApplicationContext("bank-app.xml","account-repo.xml");

or
ConfigurableApplicationContext context = new ClassPathXmlApplicationContext
new String[] { "bank-app.xml", "account-repo.xml" });


How to break the configuration in annotations?

customer
 @Configuration
 class  CustomerConfig {
   ///customer beans
 }

order
@Configuration
 class  OrderConfig {
   ///customer beans
 }
accounts
@Configuration
 class  AccountsConfig {
   ///customer beans
 }

eg:

package com.ibm.spring.app.javaconfig;


import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Service;

@Service
public class ProductService {
    public String findAll() {
        return "Product Service";
    }
}

package com.ibm.spring.app.javaconfig;

import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    public String findAll() {
        return "Customer Service";
    }
}


package com.ibm.spring.app.javaconfig;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomerConfig {
    //    @Bean //<bean class="">
    @Bean
    public CustomerService getCustomerService(){
        return  new CustomerService();
    }
}

package com.ibm.spring.app.javaconfig;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ProductConfig {

    @Bean
    public ProductService getProductService(){
        return new ProductService();
    }
}

package com.ibm.spring.app.javaconfig;


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration //beans.xml
@Import({CustomerConfig.class,ProductConfig.class})
public class AppConfig {

}

package com.ibm.spring.app.javaconfig;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class JavaConfigMain {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
        CustomerService customerService = ctx.getBean(CustomerService.class);
        System.out.println(customerService.findAll());

        ProductService productService = ctx.getBean(ProductService.class);
        System.out.println(productService.findAll());
    }
}
.....................................................................................
			How to remove bean creations from the Java config
.....................................................................................
@Component-scan

package com.ibm.spring.app.javaconfig;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class AppConfigComponentScanner {
}
package com.ibm.spring.app.javaconfig;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class JavaMainComponentScan {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfigComponentScanner.class);
        CustomerService customerService = ctx.getBean(CustomerService.class);
        System.out.println(customerService.findAll());

        ProductService productService = ctx.getBean(ProductService.class);
        System.out.println(productService.findAll());
    }
}

Note: Please disable any code which is written to create beans automatically.
...................................................................................
			@Enable Annoations
			@Enable-XXX(Feature)
....................................................................................
Enable annotation helps to inject not only bean or configuration but beyond that -  Cross Cutting Concerns

Cross Cutting Concerns:

Every Application requires some features

-Transaction
-Security
-concurrency
-caching
-AutoConfiguration
-ConfigServer

.....................................................................................
					Auto Configuration
				 Getting Spring Boot Architecture
.....................................................................................

What is Spring Boot?

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".

We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.

Spring Boot Focus Mainly Configuration

1.Build Configuration - lib configuration -pom.xml
2.Application Configuration.


Use case : i want to create WebApp using Spring- SpringMVC

Architecture:

WEB  +DATABASE CONNECTion using Mysql

Steps:

1.you have to create maven project

2.you need to add spring dependencies
   Spring-context
   Spring-web
   Spring-mvc
   mysql-connector-java
   commons-dbcp
   spring-orm
   hibernate-entitymanager
   jsr-250-api
 etc.........

3.App configuration
  src
   -main
      webapp
       -web-inf
       views
4.beans.xml / java config
   config
      WebListener COnfiguration
       -Change Spring container from plain to web
      WebAppConfig
        ViewResolver
  DataSourceConfig
  JPAConfig
.....................................................................................
			      .....................................................................................
					Auto Configuration
				 Getting Spring Boot Architecture
.....................................................................................

What is Spring Boot?

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".

We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need minimal Spring configuration.

Spring Boot Focus Mainly Configuration

1.Build Configuration - lib configuration -pom.xml
2.Application Configuration.


Use case : i want to create WebApp using Spring- SpringMVC

Architecture:

WEB  +DATABASE CONNECTion using Mysql

Steps:

1.you have to create maven project

2.you need to add spring dependencies
   Spring-context
   Spring-web
   Spring-mvc
   mysql-connector-java
   commons-dbcp
   spring-orm
   hibernate-entitymanager
   jsr-250-api
 etc.........

3.App configuration
  src
   -main
      webapp
       -web-inf
       views
4.beans.xml / java config
   config
      WebListener COnfiguration
       -Change Spring container from plain to web
      WebAppConfig
        ViewResolver
  DataSourceConfig
  JPAConfig

........................................................................................................
					Why Spring Boot?

Spring Boot 
   starters reduces build dependency
   AutoConfigrator reduces the AppDepedency
  
1.Create stand-alone Spring applications
   You can deploy apps in containers,cloud.....easily

2.Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
   SPring boots provides execuatble jar / fat jar /uber jar.	

3.Provide opinionated 'starter' dependencies to simplify your build configuration
     Looks like profie based configuration which is applied even for pom dependencies

4.Automatically configure Spring and 3rd party libraries whenever possible
    Via autoconfiguration and class path scanning.

Provide production-ready features such as metrics, health checks, and externalized configuration

Absolutely no code generation and no requirement for XML configuration
.....................................................................................

mvn dependency:tree

2/commons-collections4-4.2.jar (753 kB at 209 kB/s)
[INFO] com.ibm:myspringboot:jar:0.0.1-SNAPSHOT
[INFO] +- org.springframework.boot:spring-boot-starter:jar:3.1.1:compile
[INFO] |  +- org.springframework.boot:spring-boot:jar:3.1.1:compile
[INFO] |  |  \- org.springframework:spring-context:jar:6.0.10:compile
[INFO] |  |     +- org.springframework:spring-aop:jar:6.0.10:compile
[INFO] |  |     +- org.springframework:spring-beans:jar:6.0.10:compile
[INFO] |  |     \- org.springframework:spring-expression:jar:6.0.10:compile
[INFO] |  +- org.springframework.boot:spring-boot-autoconfigure:jar:3.1.1:compile
[INFO] |  +- org.springframework.boot:spring-boot-starter-logging:jar:3.1.1:compile
[INFO] |  |  +- ch.qos.logback:logback-classic:jar:1.4.8:compile
[INFO] |  |  |  \- ch.qos.logback:logback-core:jar:1.4.8:compile
[INFO] |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.20.0:compile
[INFO] |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.20.0:compile
[INFO] |  |  \- org.slf4j:jul-to-slf4j:jar:2.0.7:compile
[INFO] |  +- jakarta.annotation:jakarta.annotation-api:jar:2.1.1:compile
[INFO] |  +- org.springframework:spring-core:jar:6.0.10:compile
[INFO] |  |  \- org.springframework:spring-jcl:jar:6.0.10:compile
[INFO] |  \- org.yaml:snakeyaml:jar:1.33:compile
[INFO] \- org.springframework.boot:spring-boot-starter-test:jar:3.1.1:test
[INFO]    +- org.springframework.boot:spring-boot-test:jar:3.1.1:test
[INFO]    +- org.springframework.boot:spring-boot-test-autoconfigure:jar:3.1.1:test
[INFO]    +- com.jayway.jsonpath:json-path:jar:2.8.0:test
[INFO]    |  \- org.slf4j:slf4j-api:jar:2.0.7:compile
[INFO]    +- jakarta.xml.bind:jakarta.xml.bind-api:jar:4.0.0:test
[INFO]    |  \- jakarta.activation:jakarta.activation-api:jar:2.1.2:test
[INFO]    +- net.minidev:json-smart:jar:2.4.11:test
[INFO]    |  \- net.minidev:accessors-smart:jar:2.4.11:test
[INFO]    |     \- org.ow2.asm:asm:jar:9.3:test
[INFO]    +- org.assertj:assertj-core:jar:3.24.2:test
[INFO]    |  \- net.bytebuddy:byte-buddy:jar:1.14.5:test
[INFO]    +- org.hamcrest:hamcrest:jar:2.2:test
[INFO]    +- org.junit.jupiter:junit-jupiter:jar:5.9.3:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-api:jar:5.9.3:test
[INFO]    |  |  +- org.opentest4j:opentest4j:jar:1.2.0:test
[INFO]    |  |  +- org.junit.platform:junit-platform-commons:jar:1.9.3:test
[INFO]    |  |  \- org.apiguardian:apiguardian-api:jar:1.1.2:test
[INFO]    |  +- org.junit.jupiter:junit-jupiter-params:jar:5.9.3:test
[INFO]    |  \- org.junit.jupiter:junit-jupiter-engine:jar:5.9.3:test
[INFO]    |     \- org.junit.platform:junit-platform-engine:jar:1.9.3:test
[INFO]    +- org.mockito:mockito-core:jar:5.3.1:test
[INFO]    |  +- net.bytebuddy:byte-buddy-agent:jar:1.14.5:test
[INFO]    |  \- org.objenesis:objenesis:jar:3.3:test
[INFO]    +- org.mockito:mockito-junit-jupiter:jar:5.3.1:test
[INFO]    +- org.skyscreamer:jsonassert:jar:1.5.1:test
[INFO]    |  \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test
[INFO]    +- org.springframework:spring-test:jar:6.0.10:test
[INFO]    \- org.xmlunit:xmlunit-core:jar:2.9.1:test
[INFO] ------------------------------------------------------------------------

Here one pom dependency will bring all dependant libs.

AutoConfiguration:
..................

Configuration is based on config meta data provied in "META-INF/spring.factories"

org.springframework.boot.spring-autoconfigure.2.5.3

spring.factories 
  It is meta configuration file read by spring container to create objects/beans based on certain conditions -rules


Spring container scans spring.factories file , starts loading configuration, which apples @condtional 

annotations.

  Container------|AppConfig----|spring.factories----starts initalizing beans/configurations/components   based on rules(conditions) => Spring Boot.


spring-configuration-meta.json

 This file contains default "Properties and values" - application.properties file default value
 eg
 {
      "name": "spring.redis",
      "type": "org.springframework.boot.autoconfigure.data.redis.RedisProperties",
      "sourceType": "org.springframework.boot.autoconfigure.data.redis.RedisProperties"
    },
    {
      "name": "spring.redis.cluster",
      "type": "org.springframework.boot.autoconfigure.data.redis.RedisProperties$Cluster",
      "sourceType": "org.springframework.boot.autoconfigure.data.redis.RedisProperties",
      "sourceMethod": "getCluster()"
    },
  
This file is loaded during boot process

additional-spring-configuration-metadata.json

  {
      "name": "server.port",
      "defaultValue": 8080
    }

Annotations are processed by ASM - java bytecode engineering lib.
https://asm.ow2.io/
.....................................................................................
.............................................................................................................................................................................................
			Conditional Bean Creations
........................................................................................................

When building a spring boot app, we sometimes want to only load beans or modules(configurations) into the application context(container) if some conditions met, Be it disable some beans during tests, or react to a certain property in the runtime env.

Spring has annotation Called @Conditional annotation.

This annotation allows us custom conditions to apply to parts of application context.

Why Conditional Beans?

 A spring application context contains an object graph that makes up all the beans that our application needs at runtime.
@Conditional annotation allows us to define conditions under which a certain bean is included into that object graph.

eg:

 Some beans work in test env, the same bean i dont want in production env.
 enable or disable some certain cross cutting concerns.
  eg:
    we have built a module that configures security, during dev test, we dont want to have username and passwords every time. so i want to disable the whole security module in local tests.
 
 if some external resources is available without which they cant work. 
   for eg: my application should not work if there is no logback.xml file has been found on classpath.


- if beans does not exits  / exits
- if module does not exits / exits
- if external does not exitis / exits


Declaring Conditional Bean:
..........................
In application, you can declare bean any where, optionaly we can add condition.

only if this condition is satisifed will the bean added to the application context

eg:

@Configuration
class MyBeanConfig {

 @Conditional(...)
 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}


Module Level

@Configuration
@Conditional(...)
class MyBeanConfig {

 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}

Component Level

@Component
@Conditional(...)
class MyComponent {

 
}
........................................................................................................

PreDefined Conditions:
......................
1.ConditionalOnProperty 
   Loads beans based on env property - application.properties
2.ConditionalOnExpression
3.ConditionalOnBean
4.ConditionalOnMissingBean
5.ConditionalOnResource
6.ConditionalOnClass
...
ConditionalOnJava -  version based

custom conditions

Boolean Operators

Or
And
.............................................................................................

ConditionalBean:

-OnBean - The bean if  threre , what should i do

if Mysql dependency (driver jar) in the build path
     -Create Datasource Object
           -Add properties - connection string - url,password,userName


-OnMissing -Then bean if not there ,what should i do
  if web missing, then start console container

........................................................................................................
			Conditional Bean Creations
........................................................................................................

When building a spring boot app, we sometimes want to only load beans or modules(configurations) into the application context(container) if some conditions met, Be it disable some beans during tests, or react to a certain property in the runtime env.

Spring has annotation Called @Conditional annotation.

This annotation allows us custom conditions to apply to parts of application context.

Why Conditional Beans?

 A spring application context contains an object graph that makes up all the beans that our application needs at runtime.
@Conditional annotation allows us to define conditions under which a certain bean is included into that object graph.

eg:

 Some beans work in test env, the same bean i dont want in production env.
 enable or disable some certain cross cutting concerns.
  eg:
    we have built a module that configures security, during dev test, we dont want to have username and passwords every time. so i want to disable the whole security module in local tests.
 
 if some external resources is available without which they cant work. 
   for eg: my application should not work if there is no logback.xml file has been found on classpath.


- if beans does not exits  / exits
- if module does not exits / exits
- if external does not exitis / exits


Declaring Conditional Bean:
..........................
In application, you can declare bean any where, optionaly we can add condition.

only if this condition is satisifed will the bean added to the application context

eg:

@Configuration
class MyBeanConfig {

 @Conditional(...)
 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}


Module Level

@Configuration
@Conditional(...)
class MyBeanConfig {

 @Bean
 public MyBean  getBean(){ 
       return new MyBean()
 }

}

Component Level

@Component
@Conditional(...)
class MyComponent {

 
}
........................................................................................................

PreDefined Conditions:
......................
1.ConditionalOnProperty 
   Loads beans based on env property - application.properties
2.ConditionalOnExpression
3.ConditionalOnBean
4.ConditionalOnMissingBean
5.ConditionalOnResource
6.ConditionalOnClass
...
ConditionalOnJava -  version based

custom conditions

Boolean Operators

Or
And
.............................................................................................

ConditionalBean:

-OnBean - The bean if  threre , what should i do

if Mysql dependency (driver jar) in the build path
     -Create Datasource Object
           -Add properties - connection string - url,password,userName


-OnMissing -Then bean if not there ,what should i do
  if web missing, then start console container
      
package com.valtech.bootapp.conditionalonbean;

import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DependantBeanConfig {

    @Bean
    OptionalBean optionalBean() {
        return new OptionalBean();
    }

    @Bean
    @ConditionalOnBean(OptionalBean.class)
    //create this bean only if OptionalBean is available , if not dont
    DependantBean dependantBean() {
        return new DependantBean();
    }

    static class DependantBean {
        public DependantBean() {
            System.out.println("DependantBean is ready");
        }
    }

    static class OptionalBean {
        public OptionalBean() {
            System.out.println("OptionalBean is ready");

        }
    }

}
.............................................................................................
@ConditionalOnClass and @ConditionalOnMissingClass



package com.valtech.bootapp.conditionalonclass;

public class RequiredClass {
}
package com.valtech.bootapp.conditionalonclass;

import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
//@ConditionalOnClass(name = "com.valtech.bootapp.conditionalonclass.RequiredClass2")
public class SpringConfig {

    @Bean
    //@ConditionalOnClass(value = RequiredClass.class)
//    @ConditionalOnClass(name = "com.valtech.bootapp.conditionalonclass.RequiredClass")
    public MyClass getMyClass() {
        return new MyClass();
    }
    @Bean
    //@ConditionalOnClass(value = RequiredClass.class)
//    @ConditionalOnMissingClass("com.valtech.bootapp.conditionalonclass.RequiredClass1")
    public MyClass getMyClassMissing() {
        return new MyClass("Missing Class");
    }

    public static class MyClass {

        public MyClass(String message) {
            System.out.println(message);
        }

        public MyClass() {
            System.out.println("MyClass");
        }
    }
}


Conditional Componnent:

@Component
@ConditionalXXX
public class MyComponent{}

@ConditionalOnProperty("value.endabled",havingValue="true",matchIfMissing=true)
@Configuration
public class CrossCuttingModule{

}

main method

		SpringApplication application = new SpringApplication(BootappApplication.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		application.setBannerMode(Banner.Mode.OFF);
		ConfigurableApplicationContext context =application.run(args);
		HelloWorld helloWorld = context.getBean(HelloWorld.class);
		System.out.println(helloWorld.sayHello());



......................................................................................			@SpringBootApplication
....................................................................................................


@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
@SpringBootApplication


@Configuration   ------> Bean Creations - <bean>
@@SpringBootConfiguration

@EnableAutoConfiguration

 -Tells Spring boot to guess how you  want to configure spring,based on the jar dependencies that you have addeded

-IT auto configures the beans that are present in the class path.

 This simplifies the developer work by guuessing the required beans from the class path and configures to run the application.

-for eg, H2 is on your class path, you have not manually configured any database connection beans, then spring will auto configure an in memory database.


@ComponentScan
 Tells spring to look for other components,configurations and all services in the specificied package.
Spring is able to auto scan,detect  and register your beans or components from predefined project package.
if no package is specified current class package is taken as the root package.
.......................................................................................................

Spring Boot App bootstrap from java main method


SpringApplication.run(BootappApplication.class, args);

When you run this.

You will get

1.It creates ApplicationContext object -Spring Container

2.Register CommandLinePropertyResource

3.Refersh ApplicationContext

4.Trigger any CommandLineRunner Bean
.....................................................................................
Spring boot Application type:

1.Spring Pojo Style App -command Line - Core Spring App

2.Web Application - Servlet Based - Tomcat

3.Reactive Web Apps - Reactive Extensions-Project Reactor- Netty


Which application is default App?

Based on starter Dependency.
spring-boot-starter   ---- Spring Pojo Style app
.....................................................................................
			 Web Service Development In Spring
.....................................................................................

What is WebService?
    WebService is a program , distributed program , deployed on Server called web container, returns data to the users in the form of document called "XML OR json or any format which user is interested"
    WebService is just type of web application.

Types of web apps:

1.Static web app - 1989 -1995
    There is webserver which returns the document called "HTML" -
  Html files are prepared by hand in advance and kept in server.

2.Dynamic web apps - 1955 to till Date
   Where we have program which talks to database , read data and prepares html onfly/ondemand and sends to user
  Technology:
    CGI - c/perl 
    java -J2EE -servlet/jsp - webcontainer
    asp
    php
    etc...
 Drawback of this only returns html with user interface....

3.How to share data between two biz systems -  WebService - 1998 - till date
   Webservice unlike dynamic web app which transfers data via document not as html.
  In the begining Webservices were built using XML document

  Webservices based on XML Called - XML webservices aka "SOAP Webservice"

  RESTFull WebServices were introduced alternate to "SOAP Webservice"....

4.Single Page Web Apps - 2007 to till - Javascript based - Angular,react,vue.js
.....................................................................................
			   RestFull Web Service.
.....................................................................................

REST  Stands for - Representational State Transfer.

Representational - Format / Data Format

State - Data

Transfer -Moving data 

   "Moving/Transfering state from the server to clients using different formats like    xml,json,pdf,word,image...."

API:
  Application programming interface.
  API means "method/function" which encapsulate biz logic eg save,update,delete.
  APIs are organized into "classes" in object oriented programming.


package com.ibm;

import org.springframework.stereotype.Service;

@Service
public class ProductService {

    public String findAll() {
        return "Products";
    }

    public String save() {
        return "Save";
    }

    public String update() {
        return "update";
    }
}


How to invoke api?
      ProductService productService=context.getBean(ProductService.class);
        //invoke api
        System.out.println(productService.findAll());
        System.out.println(productService.save());
        System.out.println(productService.update());

We are calling api within same process(jvm).

What if theses apis need to be called from other machine/other process?

  If apis are called via networks, we need some kind of rules to invoke apis..
  Rules are nothing "Protocal".

Web is based on HTTP protocal.
We can call apis through "HTTP" Protocal".

HTTP protocal is just C program only.

HTTP C program can be classified into two category

1.Client program
   HTTP client programs talks to server program via http protocal
2.Server program
   HTTP Server programs receives the req from the client program acts accrodingly.
................

Since HTTP c program.
Any program has two things
1.variables
2.methods/functions

variables are called "headers"
methods are called "HTTP verbs" - GET,POST,DELETE,PUT,...TRACE,DEBUG....

API design and http protocal:

 Client------GET -----------------------------Server---runs GET---|mapping with api

URI: 
 It is addressing scheme to identify the "RESOURCES/API" in the server, maps accordingly...

REST Spec:
https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
....................................................................................
			 API design and http protocal


 Client ----GET /api/customers--------|webserver---|webcontainer--|API class..
....................................................................................

API Technology:

1.HTTP based API -> SOAP,RESTFull apis,GraphQL
2.RPC ---------->Grpc apis
3.MOM ----------->RabbitmQ...
.....................................................................................
		           REST Principles- Architecutral Constraints

1.Uniform interface -URL
2.Client-Server
3.Stateless
4.Cacheable
5.Layered System
6.Code on demand(optionl)
....................................................................................
			   REST Principles in java
..................................................................................

JEE proposed a spec to implement WebServices

1.JAX WS - Java API for XML Web Service - SOAP based 
2.JAX RS - Java API for RestFull web services-  REST based

How we can use Spring to build RESTfull WebService?

 Spring did not follow or implement "JAX RS SPEC" - Spring addeded their own implementation on the top of "Servlet".
...................................................................................
			 Spring and Restfull Web Service Integration
....................................................................................

Before RestFull Web services, Spring had "Dynamic web app development" module called Spring-MVC.

Spring added new Layer on the top of Spring-MVC to build restfull apis by just introduction different annotations.

How to start creating Spring Boot for building Rest api?
spring-boot-starter-web
  -can be used to build dynamic content apps- view based apps
  -can be used to build dynamic content apps- Resources based apps

pom.xml
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

.....................................................................................

Steps to Design Rest api:
.........................

API means the program which has biz functionality.

According to REST Principle;

 The Biz or domain functionality must be exposed as Resource.

Resource:
 It could be any thing which is accessiable via URL/URI.
In general biz systems has collection of Objects like Product,Customer,Account...
Every Object is called Resource.

In Spring How to expose Resource?

Controller.

What is controller?
 Controller is simple java class which is annotated by "@RestController"

package com.ibm.app.resources;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class CustomerController {
    //apis
    public String findAll() {
        return "Customers";
    }

}

How to identify the controller/Resource by clients?

Using URI.
@RequestMapping annotation is used to map resources by URI.
package com.ibm.app.resources;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/customers")
public class CustomerController {
    //apis
    public String findAll() {
        return "Customers";
    }

}

API Representation. How to access?

Any biz system we have many operations

CURD operations:

1.CREATE
2.SELECT
3.UPDATE
4.DELETE

IN http CURD operations are mapped by the following verbs

1.GET - SELECT-READ
2.POST - CREATE-INSERT
3.PUT  - UPDATE
4.DELETE - REMOVE

Annotations to map the http VERBS

1.GET - @GetMapping
2.POST - @PostMapping
3.PUT  - @PutMapping
4.DELETE - @DeleteMapping

package com.ibm.app.resources;


import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/customers")
public class CustomerController {
    //apis
    //readAll
    @GetMapping
    public String findAll() {
        return "Customers";
    }

    @PostMapping
    //save
    public String save() {
        return "Save";
    }

    @PutMapping
    //update
    public String update() {
        return "update";
    }

    @DeleteMapping
    //remove
    public String remove() {
        return "Delete";
    }
}

Client:
  Client is just another program.

Generally java script can be client program- browser based apps
Java itself can be client program
Any other programming language can also be client program.

In dev env, dev test Rest api using tools like

PostMan
CURL

Request Format:

GET /api/customers


package com.ibm.app.resources;


import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/customers")
public class CustomerController {
    //apis
    //readAll
    @GetMapping
    public String findAll() {
        return "Customers";
    }

    @PostMapping
    //save
    public String save() {
        return "Save";
    }

    @PutMapping
    //update
    public String update() {
        return "update";
    }

    @DeleteMapping
    //remove
    public String remove() {
        return "Delete";
    }
}
.....................................................................................

URL Mapping on the top of api:
.............................
package com.ibm.app.resources;


import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/customers")
public class CustomerController {
    //apis
    //readAll
    @GetMapping
    public String findAll() {
        return "Customers";
    }

    //Sub URL
    @GetMapping("/list")
//    @RequestMapping("/list")
    public String list(){
        return "Customer list";
    }


    @PostMapping
    //save
    public String save() {
        return "Save";
    }

    @PutMapping
    //update
    public String update() {
        return "update";
    }

    @DeleteMapping
    //remove
    public String remove() {
        return "Delete";
    }
}
....................................................................................
				API structure
...................................................................................

api is just method.
any method which may take arg and also it may return values.

public String findAll() {
        return "Customers";
}

Return Value:Reponse Types
1.String
2.Object - Plain Domain Object or Collection like List or Set or Array
3.ResponseEntity
4.void

Response:
  The Response nothing but the output of the api which is sent over http protocal.

Response Contains two things

1.Payload - Data which is returned
2.Meta Data(Headers)
   Headers are just variables which hold some values which describe the nature of response.

Response Headers
................
1.Content-Type

Content-Type: text/html; charset=utf-8

The MIME type of this content. What type of data server is sending to client.

Basic content type of web is:
  HTML
  Plain/text
Rest content type is :
  
  Representational State Transfer
      |             |
   Data Format     Data
      |
json
xml
pdf
word
etc...

By Default in REST is "json"

2.Content-Length

Content-Length: 348

The length of the response body expressed in 8-bit bytes


3.Date
Date: Tue, 15 Nov 1994 08:12:31 GMT

The date and time that the message was sent (in “HTTP-date” format as defined by RFC 7231)

4.keep-alive
  It is header which talks how long the http connection can exits between server and client default is 60ms

5.Connection
Connection: close

Control options for the current connection and list of hop-by-hop response fields. Deprecated in HTTP/2

.....................................................................................
				JSON as Representation
.....................................................................................

How Can Spring send Json?
Spring uses JSON converter to convert any object/collection/array into json automatically.

package com.ibm.app.resources;

import com.ibm.app.resources.entity.User;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    //@GetMapping(produces = {"application/json"})
    @GetMapping
    public User findAll() {
        return new User(1, "Subramanian");
    }

    //How to send list of Users
    @GetMapping("/list")
    public List<User> list() {
        return List.of(new User(1, "Subramanian"), new User(2, "Ram"));
    }
}
.....................................................................................
			Sending Status Code
....................................................................................

HTTP operation Status:

-> informational response - 100 to 199-1X
-> success response -  200-299-2X
-> Redirects  - 300-399 -3X
-> client errors - 400-499 -4X
-> server errrors - 500-599 - 5X

Status Code : 100 to 500

1XX Information Responses

100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2XX Success

200 OK
201 Created
202 Accepted
203 Non-Authoritative Information
204 No Content
205 Reset Content
206 Partial Content
207 Multi-Status
208 Already Reported
226 IM Used

3XX Redirection
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
305 Use Proxy
306 Switch Proxy
307 Temporary Redirect
308 Permanent Redirect

4XX Client errors

400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Precondition Failed
413 Payload Too Large
414 URI Too Long
415 Unsupported Media Type
416 Range Not Satisfiable
417 Expectation Failed
418 I'm a teapot
420 Method Failure
421 Misdirected Request
422 Unprocessable Entity
423 Locked
424 Failed Dependency
426 Upgrade Required
428 Precondition Required
429 Too Many Requests
431 Request Header Fields Too Large
451 Unavailable For Legal Reasons

5XX Server errors
500 Internal Server error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 gateway Timeout
505 Http version not supported
506 Varient Also negotiate
507 Insufficient Storage
508 Loop Detected
510 Not Extended
511 Network Authentication Required

 "By default spring sends 200 status for all success request and response."

What if i want to send some special status code?

According to Rest , Post method must return 201.

How to add StatusCode in the Response?

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String save(){
        return "Saved";
    }

What if i dont send any content? - 204-NotContent
   
    @GetMapping("/process")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public  void process(){
        System.out.println("Processed");
    }
.....................................................................................
		Sending Payload,StatusCode,Custom Http /or Built in HttpHeader
.....................................................................................

ResponseEntity:
  It is Type which is returned by api

You can encapulsate  payload,status code,Headers.

ResponseEntity Object has been desinged based "commandChain or builder Pattern"

  The builder pattern is nothing but object methods return the same object and you start chain until full object is constructed.

   @GetMapping("/listresponse")
    public ResponseEntity<List<User>> listResponse() {
        List<User> users = List.of(new User(1, "Subramanian"), new User(2, "Ram"));
        return ResponseEntity
                .status(HttpStatus.OK)
                .header("secrete", "foobar")
                .contentType(MediaType.APPLICATION_JSON)
                .body(users);
    }
.....................................................................................
			API Args
.....................................................................................
Client can send data to REST API.

Data can be sent in two ways 
1.via parameters
2.via payload

1.Parameters : According to REST specfication
   -Path Parameters
   -Query Parameters
   -Matrix Parameters
   -Form Parameters
2.Payload
   -Any thing(data) can be embeded into HTTP body and sent to Server

HTTP Request Structure:
......................
Request contains two segments

1.Request Headers
   We pass Request Headers
2.Request Body 
    We pass data 

Parmeters vs Payload:
.....................
Parameters and payload both are used to send data to server .

Parameters send data via "URL" /as part of the URL....

http://www.example.com/api/users/23
http://www.example.com/api/products?sorting=asyn

here 23 and sorting=asyn are data

Payload is used to send data as part of Request body which is hidden from the user, we cant see.

Suppose if i want send "Customer information,Product Information" as json

...................................................................................
			Sending data via URL - Path Parameter
...................................................................................
Path Parameters are used to get information based on input - Dynamic URLS

Path Parameters Synatx:

  -Query Information based on dynamic input called path

   /api/resource/{placeholder}
   /api/orders/1
   /api/orders/2

GET http://example.com/api/users/1

package com.ibm.app.resources;

import com.ibm.app.resources.entity.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    //@GetMapping(produces = {"application/json"})
    @GetMapping
    public User findAll() {
        return new User(1, "Subramanian");
    }

    // /api/users/1
    @GetMapping(value = "/{id}")
    public String findById(@PathVariable("id") String id) {
        return id + "details";
    }

    //How to send list of Users
    @GetMapping("/list")
    public List<User> list() {
        return List.of(new User(1, "Subramanian"), new User(2, "Ram"));
    }

    @GetMapping("/listresponse")
    public ResponseEntity<List<User>> listResponse() {
        List<User> users = List.of(new User(1, "Subramanian"), new User(2, "Ram"));
        return ResponseEntity
                .status(HttpStatus.OK)
                .header("secrete", "foobar")
                .contentType(MediaType.APPLICATION_JSON)
                .body(users);
    }


    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String save() {
        return "Saved";
    }

    @GetMapping("/process")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void process() {
        System.out.println("Processed");
    }

}

Testing:
http://localhost:8080/api/users/4
.....................................................................................
		QueryParam /Query Strings/ Request Parameters
.....................................................................................

Syntax:
http://www.example.com/api/products?sorting=asyn&filter=city


  //http://localhost:8080/api/users/filter?ranking=Premium

    @GetMapping(value = "/filter")
    public String filter(@RequestParam("ranking") String ranking) {
        return ranking;
    }
...................................................................................
			 Sending Payload to Server
...................................................................................

What if i want to send user json?

{
    "id": 1,
    "name": "Subramanian"
}
We have to send via Payload.

How to receive Payload in the server?
  @RequestBody


   @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String save(@RequestBody User user) {
        System.out.println(user);
        return "Saved";
    }

PostMan:
POST http://localhost:8080/api/users

{
    "id": 2,
    "name": "John"
}
package com.ibm.app.resources;

import com.ibm.app.resources.entity.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    //@GetMapping(produces = {"application/json"})
    @GetMapping
    public User findAll() {
        return new User(1, "Subramanian");
    }

    // /api/users/1
    @GetMapping(value = "/{id}")
    public String findById(@PathVariable("id") String id) {
        return id + "details";
    }

    @GetMapping(value = "/filter")
    public String filter(@RequestParam("ranking") String ranking) {
        return ranking;
    }

    //How to send list of Users
    @GetMapping("/list")
    public List<User> list() {
        return List.of(new User(1, "Subramanian"), new User(2, "Ram"));
    }

    @GetMapping("/listresponse")
    public ResponseEntity<List<User>> listResponse() {
        List<User> users = List.of(new User(1, "Subramanian"), new User(2, "Ram"));
        return ResponseEntity
                .status(HttpStatus.OK)
                .header("secrete", "foobar")
                .contentType(MediaType.APPLICATION_JSON)
                .body(users);
    }


    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String save(@RequestBody User user) {
        System.out.println(user);
        return "Saved";
    }

    @GetMapping("/process")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void process() {
        System.out.println("Processed");
    }

}
.....................................................................................
		 Data Layer Integration-Isloate the biz logic outside controller
.....................................................................................
Spring Rest + ORM Integration(JPA/Hibernate)

Software setup:
1.Database Server-Mysql or postgreSql or oracle or h2....

Mysql:

How to install database server?

There are two ways 
1.direct installation 
https://dev.mysql.com/downloads/installer/
2.via Docker
 This is most popular and highly recommended

Incase of your setup is docker,You can start mysql server via docker.

create docker-compose.yml in the project root dir

<project-name>
   |
   docker-compose.yml

version: '3.3'
services:
  db:
    image: mysql:5.7
    restart: always
    environment:
      MYSQL_DATABASE: 'db'
      # So you don't have to use root, but you can if you like
      MYSQL_USER: 'user'
      # You can use whatever password you like
      MYSQL_PASSWORD: 'password'
      # Password for root access
      MYSQL_ROOT_PASSWORD: 'password'
    ports:
      # <Port exposed> : <MySQL Port running inside container>
      - '3306:3306'
    expose:
      # Opens port 3306 on the container
      - '3306'
      # Where our data will be persisted
    volumes:
      - my-db:/var/lib/mysql
# Names our volume
volumes:
  my-db:

How to start mysql server?
docker-compose up

After mysql server start up, you can use mysql client utlity to check the database information.

Open docker terminal in the docker-desktop

mysql -uroot -p

After login:
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db                 |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)

mysql> select database();
+------------+
| database() |
+------------+
| NULL       |
+------------+
1 row in set (0.00 sec)

mysql> use db
Database changed
mysql> select database();
+------------+
| database() |
+------------+
| db         |
+------------+
1 row in set (0.00 sec)
.....................................................................................

Spring Boot JPA Dependency:
pom.xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

Spring jdbc connector
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>


How to connect database from the application?

We need  connectionString configuration and also basic hibernate configuration.

application.properties
   This is file where we can mention all configuration for an app.

spring.datasource.url= jdbc:mysql://localhost:3306/db?useSSL=false
spring.datasource.username= user
spring.datasource.password= password

spring.jpa.properties.hibernate.dialect= org.hibernate.dialect.MySQLDialect
spring.jpa.hibernate.ddl-auto= update

.....................................................................................
Create JPA Entity:
 JPA Entity is object which represents table in database.

@Entity
@Table
@Id
@Generated
@Column
etc...

Table : Tutorial
mysql> desc tutorials;
+-------------+--------------+------+-----+---------+-------+
| Field       | Type         | Null | Key | Default | Extra |
+-------------+--------------+------+-----+---------+-------+
| id          | bigint(20)   | NO   | PRI | NULL    |       |
| description | varchar(255) | YES  |     | NULL    |       |
| published   | bit(1)       | YES  |     | NULL    |       |
| title       | varchar(255) | YES  |     | NULL    |       |
+-------------+--------------+------+-----+---------+-------+

API Design :

Methods	    Urls	        Actions

POST	/api/tutorials   	create new Tutorial
GET	/api/tutorials	        retrieve all Tutorials
GET	/api/tutorials/:id	retrieve a Tutorial by :id
PUT	/api/tutorials/:id	update a Tutorial by :id
DELETE	/api/tutorials/:id	delete a Tutorial by :id
DELETE	/api/tutorials	        delete all Tutorials
GET	/api/tutorials/published	find all published Tutorials
GET	/api/tutorials?title=[keyword]	find all Tutorials which title contain

....................................................................................
				Repository Layer
....................................................................................

Spring offers Design  pattern called DAO implementation.

According to DAO , we need to offer api which hides database query operations.

JPA and hibernate provides such abstraction.

Spring boot even provides readymade apis , you dont need to write even single basic curd operation.


package com.ibm.app.jpa.repository;

import com.ibm.app.jpa.enity.Tutorial;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

//This repository provides all basic operations but if you want extra api also you can add.
public interface TutorialRepository extends JpaRepository<Tutorial,Long> {
    //Extra apis
    List<Tutorial> findByPublished(boolean published);
    List<Tutorial> findByTitleContaining(String title);
}

...

Controller:
package com.ibm.app.jpa;


import com.ibm.app.jpa.enity.Tutorial;
import com.ibm.app.jpa.repository.TutorialRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/tutorials")
public class TutorialController {
    //di
    @Autowired
    private TutorialRepository tutorialRepository;

    //Get all Tutorial
    @GetMapping
    public ResponseEntity<List<Tutorial>> getAllTutorials(@RequestParam(required = false) String title) {
        try {
            List<Tutorial> tutorials = new ArrayList<Tutorial>();

            if (title == null)
                tutorialRepository.findAll().forEach(tutorials::add);
            else
                tutorialRepository.findByTitleContaining(title).forEach(tutorials::add);

            if (tutorials.isEmpty()) {
                return new ResponseEntity<>(HttpStatus.NO_CONTENT);
            }
            //return  ResponseEntity<>(tutorials, HttpStatus.OK);
            return ResponseEntity.status(HttpStatus.OK).body(tutorials);

        } catch (Exception e) {
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    //post operation
    @PostMapping
    public ResponseEntity<Tutorial> createTutorial(@RequestBody Tutorial tutorial) {
        try {
            Tutorial _tutorial = tutorialRepository
                    .save(new Tutorial(tutorial.getTitle(), tutorial.getDescription(), false));
            return new ResponseEntity<>(_tutorial, HttpStatus.CREATED);
        } catch (Exception e) {
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }


    @GetMapping("/{id}")
    public ResponseEntity<Tutorial> getTutorialById(@PathVariable("id") long id) {

        Optional<Tutorial> tutorialData = tutorialRepository.findById(id);

        if (tutorialData.isPresent()) {
            return new ResponseEntity<>(tutorialData.get(), HttpStatus.OK);
        } else {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<Tutorial> updateTutorial(@PathVariable("id") long id, @RequestBody Tutorial tutorial) {
        Optional<Tutorial> tutorialData = tutorialRepository.findById(id);

        if (tutorialData.isPresent()) {
            Tutorial _tutorial = tutorialData.get();
            _tutorial.setTitle(tutorial.getTitle());
            _tutorial.setDescription(tutorial.getDescription());
            _tutorial.setPublished(tutorial.isPublished());
            return new ResponseEntity<>(tutorialRepository.save(_tutorial), HttpStatus.OK);
        } else {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }
    @GetMapping("/published")
    public ResponseEntity<List<Tutorial>> findByPublished() {
        try {
            List<Tutorial> tutorials = tutorialRepository.findByPublished(true);

            if (tutorials.isEmpty()) {
                return new ResponseEntity<>(HttpStatus.NO_CONTENT);
            }
            return new ResponseEntity<>(tutorials, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    @DeleteMapping("/{id}")
    public ResponseEntity<HttpStatus> deleteTutorial(@PathVariable("id") long id) {
        try {
            tutorialRepository.deleteById(id);
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (Exception e) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @DeleteMapping("/tutorials")
    public ResponseEntity<HttpStatus> deleteAllTutorials() {
        try {
            tutorialRepository.deleteAll();
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (Exception e) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }

    }


}
.....................................................................................
		   Rest api design with JPA/Hibernate One To One mapping
.....................................................................................
Methods	Urls	Actions

POST	/api/tutorials/:id/details	create new Details for a Tutorial
GET	/api/details/:id	retrieve Details by :id
GET	/api/tutorials/:id/details	retrieve Details of a Tutorial
PUT	/api/details/:id	update Details by :id
PUT	/api/tutorials/:id/details	update Details of a Tutorial
DELETE	/api/details/:id	delete Details by :id
DELETE	/api/tutorials/:id/details	delete Details of a Tutorial
DELETE	/api/tutorials/:id	delete a Tutorial (and its Details)


Steps:
Entity:
package com.ibm.app.jpa.onetomany;

import jakarta.persistence.*;

import java.util.Date;

@Entity
@Table(name = "tutorial_details")
public class TutorialDetails {
    @Id
    private Long id;

    @Column
    private Date createdOn;

    @Column
    private String createdBy;

    //primary key and forg
    @OneToOne(fetch = FetchType.LAZY)
    @MapsId
    @JoinColumn(name = "tutorial_id")
    private MyTutorial tutorial;

    public TutorialDetails() {
    }

    public TutorialDetails(String createdBy) {
        this.createdOn = new Date();
        this.createdBy = createdBy;
    }

    public Date getCreatedOn() {
        return createdOn;
    }

    public void setCreatedOn(Date createdOn) {
        this.createdOn = createdOn;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }

    public MyTutorial getTutorial() {
        return tutorial;
    }

    public void setTutorial(MyTutorial tutorial) {
        this.tutorial = tutorial;
    }

}



Entity:Master Entity
package com.ibm.app.jpa.onetomany;

import jakarta.persistence.*;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties({"hibernateLazyInitializer"})
@Entity
@Table(name = "mytutorials")
public class MyTutorial {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(name = "title")
    private String title;

    @Column(name = "description")
    private String description;

    @Column(name = "published")
    private boolean published;

    public MyTutorial() {

    }

    public MyTutorial(String title, String description, boolean published) {
        this.title = title;
        this.description = description;
        this.published = published;
    }

    public long getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public boolean isPublished() {
        return published;
    }

    public void setPublished(boolean isPublished) {
        this.published = isPublished;
    }

    @Override
    public String toString() {
        return "Tutorial [id=" + id + ", title=" + title + ", desc=" + description + ", published=" + published + "]";
    }

}
  
After running :
    '> mysql> desc mytutorials;
    '> +-------------+--------------+------+-----+---------+----------------+
    '> | Field       | Type         | Null | Key | Default | Extra          |
    '> +-------------+--------------+------+-----+---------+----------------+
    '> | id          | bigint(20)   | NO   | PRI | NULL    | auto_increment |
    '> | description | varchar(255) | YES  |     | NULL    |                |
    '> | published   | bit(1)       | YES  |     | NULL    |                |
    '> | title       | varchar(255) | YES  |     | NULL    |                |
    '> +-------------+--------------+------+-----+---------+----------------+
    '> 4 rows in set (0.00 sec)
    '> 
    '> mysql> desc tutorial_details;
    '> +-------------+--------------+------+-----+---------+-------+
    '> | Field       | Type         | Null | Key | Default | Extra |
    '> +-------------+--------------+------+-----+---------+-------+
    '> | tutorial_id | bigint(20)   | NO   | PRI | NULL    |       |
    '> | created_by  | varchar(255) | YES  |     | NULL    |       |
    '> | created_on  | datetime(6)  | YES  |     | NULL    |       |
    '> +-------------+--------------+------+-----+---------+-------+

Repository:


package com.ibm.app.jpa.onetomany;

import jakarta.transaction.Transactional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TutorialDetailsRepository extends JpaRepository<TutorialDetails, Long> {
    @Transactional
    void deleteById(long id);
    @Transactional
    void deleteByTutorialId(long tutorialId);
}

package com.ibm.app.jpa.onetomany;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;


public interface MyTutorialRepository extends JpaRepository<MyTutorial, Long> {
    List<MyTutorial> findByPublished(boolean published);

    List<MyTutorial> findByTitleContaining(String title);
}
.....................................................................................

package com.ibm.app.jpa.onetomany;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class MyTutorialController {

    @Autowired
    MyTutorialRepository tutorialRepository;

    @Autowired
    private TutorialDetailsRepository detailsRepository;

    @GetMapping("/mytutorials")
    public ResponseEntity<List<MyTutorial>> getAllTutorials(@RequestParam(required = false) String title) {
        List<MyTutorial> tutorials = new ArrayList<MyTutorial>();

        if (title == null)
            tutorialRepository.findAll().forEach(tutorials::add);
        else
            tutorialRepository.findByTitleContaining(title).forEach(tutorials::add);

        if (tutorials.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(tutorials, HttpStatus.OK);
    }

    @GetMapping("/mytutorials/{id}")
    public ResponseEntity<MyTutorial> getTutorialById(@PathVariable("id") long id) {
        MyTutorial tutorial = tutorialRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Not found Tutorial with id = " + id));

        return new ResponseEntity<>(tutorial, HttpStatus.OK);
    }

    @PostMapping("/mytutorials")
    public ResponseEntity<MyTutorial> createTutorial(@RequestBody MyTutorial tutorial) {
        MyTutorial _tutorial = tutorialRepository.save(new MyTutorial(tutorial.getTitle(), tutorial.getDescription(), true));
        return new ResponseEntity<>(_tutorial, HttpStatus.CREATED);
    }

    @PutMapping("/mytutorials/{id}")
    public ResponseEntity<MyTutorial> updateTutorial(@PathVariable("id") long id, @RequestBody MyTutorial tutorial) {
        MyTutorial _tutorial = tutorialRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Not found Tutorial with id = " + id));

        _tutorial.setTitle(tutorial.getTitle());
        _tutorial.setDescription(tutorial.getDescription());
        _tutorial.setPublished(tutorial.isPublished());

        return new ResponseEntity<>(tutorialRepository.save(_tutorial), HttpStatus.OK);
    }

    @DeleteMapping("/mytutorials/{id}")
    public ResponseEntity<HttpStatus> deleteTutorial(@PathVariable("id") long id) {
        if (detailsRepository.existsById(id)) {
            detailsRepository.deleteById(id);
        }

        tutorialRepository.deleteById(id);

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @DeleteMapping("/mytutorials")
    public ResponseEntity<HttpStatus> deleteAllTutorials() {
        tutorialRepository.deleteAll();

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @GetMapping("/mytutorials/published")
    public ResponseEntity<List<MyTutorial>> findByPublished() {
        List<MyTutorial> tutorials = tutorialRepository.findByPublished(true);

        if (tutorials.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(tutorials, HttpStatus.OK);
    }
}


package com.ibm.app.jpa.onetomany;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class TutorialDetailsController {
    @Autowired
    private TutorialDetailsRepository detailsRepository;

    @Autowired
    private MyTutorialRepository tutorialRepository;

    @GetMapping({"/details/{id}", "/mytutorials/{id}/details"})
    public ResponseEntity<TutorialDetails> getDetailsById(@PathVariable(value = "id") Long id) {
        TutorialDetails details = detailsRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Not found Tutorial Details with id = " + id));

        return new ResponseEntity<>(details, HttpStatus.OK);
    }

    @PostMapping("/mytutorials/{tutorialId}/details")
    public ResponseEntity<TutorialDetails> createDetails(@PathVariable(value = "tutorialId") Long tutorialId,
                                                         @RequestBody TutorialDetails detailsRequest) {
        MyTutorial tutorial = tutorialRepository.findById(tutorialId)
                .orElseThrow(() -> new ResourceNotFoundException("Not found Tutorial with id = " + tutorialId));

        detailsRequest.setCreatedOn(new java.util.Date());
        detailsRequest.setTutorial(tutorial);
        TutorialDetails details = detailsRepository.save(detailsRequest);

        return new ResponseEntity<>(details, HttpStatus.CREATED);
    }

    @PutMapping("/details/{id}")
    public ResponseEntity<TutorialDetails> updateDetails(@PathVariable("id") long id,
                                                         @RequestBody TutorialDetails detailsRequest) {
        TutorialDetails details = detailsRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Id " + id + " not found"));

        details.setCreatedBy(detailsRequest.getCreatedBy());

        return new ResponseEntity<>(detailsRepository.save(details), HttpStatus.OK);
    }

    @DeleteMapping("/details/{id}")
    public ResponseEntity<HttpStatus> deleteDetails(@PathVariable("id") long id) {
        detailsRepository.deleteById(id);

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @DeleteMapping("/mytutorials/{tutorialId}/details")
    public ResponseEntity<TutorialDetails> deleteDetailsOfTutorial(@PathVariable(value = "tutorialId") Long tutorialId) {
        if (!tutorialRepository.existsById(tutorialId)) {
            throw new ResourceNotFoundException("Not found Tutorial with id = " + tutorialId);
        }

        detailsRepository.deleteByTutorialId(tutorialId);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}


Steps:

POST http://localhost:8080/api/tutorials
{
    "title": "springboot",
    "description": "desc",
    "published": true
}

POST http://localhost:8080/api/tutorials/1/details
 {
     "createdBy":"Subramanian"
 }
Response
{
    "createdOn": "2023-06-27T15:41:50.285+00:00",
    "createdBy": "Subramanian",
    "tutorial": {
        "id": 1,
        "title": "springboot",
        "description": "desc",
        "published": true
    }
}
................................****************....................................
Assigment:

1.Order - Product
 OneToMany- Relationship or OneToOne

POST	/api/orders/:id/productdetails	
GET	/api/orders/:id	
GET	/api/orders/:id/details	
PUT	/api/orders/:id	
PUT	/api/productdetails/:id/orderdetails
DELETE	/api/productdetails/:id	
DELETE	/api/orders/:id/orderproducts	
DELETE	/api/orders/:id	

https://github.dev/GreenwaysTechnology/IBM-SpringRest-Jun-23






  




























      